---
title: "Assignment 7: Lightning simulation"
author: "Bence Gergely"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(matrixStats)
```


# Task

- Create a random lightning algorithm, and visualize the result!
- The lightning should be a random walk from top to bottom.
- At each step, there is a 1% chance of forking.
- Each fork in itself is a new random walk.
- The forks do not need to fork further.
- Visualize the lightning, preferably using black background and blue/white foreground color. 
- (extra point) Try to do this using no loops! (loops are ok, but you can earn less points)
- (extra point) Create an animation using gganimate, where the lightning hits from above to below.

# Dataset

There is no dataset for this project. You have to simulate from scratch!

# Example lightning

![Lightning](assignment_7_example/example_lightning.png)
# Random walks with branching

The main idea behind the algorithm was to use the flexible nature of the vector object in R.
In every iteration I tested whether there is a branching, and if there was I added a new element to the current step vector.
This vector contained the current horizontal position of the lightning, the vertical position was incremented in every iteration with one.


## Creating the lightning settings
```{r, settings}
size_x = size_y = 256
canvas = matrix(0, size_x, size_y)

#initial value
canvas[1, 129] = 1

```


## Creating the lighning algorithm with for loops

```{r, lightning_algorithm}
lightning_position = list(c(129))
possible_steps = c(-1, 0, 1)

for(rows in 2:nrow(canvas)){
  current_steps  = lightning_position[[rows - 1]] 
  alpha = runif(1)
  if(alpha < 0.01){
    current_steps = c(current_steps, current_steps[1])
    lightning_position[[rows]] = 
      c(current_steps + sample(possible_steps,length(current_steps), replace = TRUE))
  } else {
    lightning_position[[rows]] = 
      c(current_steps + sample(possible_steps, length(current_steps), replace = TRUE))
    canvas[rows, lightning_position[[rows]]] = 1
  }
  
}

```


## Plot the results

```{r, plotting1}

plot1 = ggplot(data = as.data.frame(colCumsums(canvas)), aes(x = 1:size_x))

for(i in 1:size_x){
  plot1 = plot1 + geom_line(y = as.data.frame(colCumsums(canvas))[,i], col = "black")
}

plot1

```



## Vectorised lightning algorithm 

If we want to write this algorithm without explicit for loops, we can do 2 things: 1) use an implicit loop like apply or map (from package purrr), or vectorise the whole algorithm. In the following we are going to do the latter.

First we are creating a matrix filled with a random walk which will be the trajectory of the main lightning. Then we will delete the lower triangular matrix of the transposed matrix and fill it with random trajectories. This will represent a lightning which is branching in every iteration. Last, we are creating a matrix with binary values, which will signal whether the given branching happened or not. A row will be filled with 1-s with 0.01 probabilty.

### Creating a random walk
```{r, loopless_lightning1}
starting_value = 16
length_of_lightning = 16
main_lightning = cumsum(sample(c(-1,0,1), size = length_of_lightning, replace = TRUE))

```

### Creating the lightning matrix which is branching in every step.
```{r, loopless_lightning1}


rep_main_lightning = rep(main_lightning, times = length_of_lightning)
ever_branching_lightning = matrix(rep_main_lightning,length_of_lightning, length_of_lightning, byrow = TRUE)
ever_branching_lightning[upper.tri(ever_branching_lightning)] = 0

branching_walks = sample(c(-1,0,1), size = length_of_lightning * length_of_lightning, replace = TRUE)
random_branches_matrix = matrix(branching_walks, length_of_lightning, length_of_lightning, byrow = TRUE)
random_branches_matrix[lower.tri(random_branches_matrix)] = 0
random_branches_matrix = rowCumsums(random_branches_matrix)

ever_branching_lightning = ever_branching_lightning + random_branches_matrix + starting_value

```

### Creating the probability matrix to decide on the branching
```{r, loopless_lightning2}

prob_vector = runif(length_of_lightning - 1)
prob_vector = c(as.numeric(prob_vector < 0.1), 1)

prob_rep_vector = rep(prob_vector, length_of_lightning)
prob_matrix = t(matrix(prob_rep_vector, length_of_lightning, length_of_lightning, byrow = TRUE))

```

### Final lightning matrix
```{r, loopless_lightning3}

final_lightning = t(ever_branching_lightning * prob_matrix)
print(final_lightning)



```


```{r, plotting1}

plot2 = ggplot(data = as.data.frame(final_lightning), aes(x = 1:length_of_lightning))

for(i in 1:size_x){
  plot2 = plot2 + geom_line(y = as.data.frame(final_lightning)[i,], col = "black")
}

plot2
```
